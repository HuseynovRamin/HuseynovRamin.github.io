<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Real Head Volleyball Game</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

    /* PAGE AND BACKGROUND */
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(to top, #87CEEB 0%, #d9f7e9 60%, #6AC1A0 100%);
      font-family: 'Orbitron', monospace;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      -webkit-tap-highlight-color: transparent;
      position: relative;
    }

    #scoreboard {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      font-size: 40px;
      color: #164C3F;
      text-shadow: 0 0 10px #00FFB3;
      background: rgba(255 255 255 / 0.2);
      padding: 12px 0;
      backdrop-filter: blur(8px);
      border-radius: 10px;
      pointer-events: none;
      user-select: none;
      font-weight: 700;
      letter-spacing: 2px;
      z-index: 10;
    }

    #gameCanvas {
      border-radius: 20px;
      box-shadow:
        0 0 20px 5px rgba(30, 150, 100, 0.8),
        inset 0 0 40px 5px rgba(255 255 255 / 0.15);
      background: linear-gradient(135deg, #1E5A4B 0%, #3E8E7E 100%);
      touch-action: none;
      user-select: none;
      display: block;
    }

    /* Countdown overlay */
    #countdownOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(10, 10, 10, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 120px;
      font-weight: 900;
      color: #00FFB3;
      text-shadow: 0 0 20px #00FFB3, 0 0 40px #00FFB3;
      user-select: none;
      z-index: 100;
      font-family: 'Orbitron', monospace;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="scoreboard">Player: 0 | AI: 0</div>
  <canvas id="gameCanvas" width="900" height="500"></canvas>
  <div id="countdownOverlay">3</div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const countdownOverlay = document.getElementById('countdownOverlay');

    // CONSTANTS
    const gravity = 0.65;
    const floorY = canvas.height - 50;
    const netX = canvas.width / 2 - 5;
    const netHeight = 120;
    const netWidth = 10;

    // Load images for heads (replace URLs with your own!)
    const playerHeadImg = new Image();
    playerHeadImg.src = 'https://i.ibb.co/G7xZs1W/player-head.png'; // example image, replace

    const aiHeadImg = new Image();
    aiHeadImg.src = 'https://i.ibb.co/J2zLVPJ/ai-head.png'; // example image, replace

    // BALL IMAGE (optional, else draw circle)
    const ballImg = new Image();
    ballImg.src = 'https://i.ibb.co/VQ7djRF/volleyball.png'; // example volleyball image, replace

    // Player and AI class with images
    class Player {
      constructor(x, img, leftBound, rightBound) {
        this.x = x;
        this.y = floorY - 80;
        this.radius = 40; // head image size radius for hitbox
        this.img = img;
        this.dy = 0;
        this.jumping = false;

        this.speedX = 0;
        this.acceleration = 0.6;
        this.maxSpeed = 8;
        this.friction = 0.85;

        this.leftBound = leftBound;
        this.rightBound = rightBound;

        // Bounce animation on hit
        this.headBounce = 0;
      }

      moveLeft() {
        this.speedX -= this.acceleration;
        if (this.speedX < -this.maxSpeed) this.speedX = -this.maxSpeed;
      }
      moveRight() {
        this.speedX += this.acceleration;
        if (this.speedX > this.maxSpeed) this.speedX = this.maxSpeed;
      }
      jump() {
        if (!this.jumping) {
          this.dy = -14;
          this.jumping = true;
        }
      }

      update() {
        this.speedX *= this.friction;
        if (Math.abs(this.speedX) < 0.1) this.speedX = 0;

        this.x += this.speedX;
        if (this.x - this.radius < this.leftBound) {
          this.x = this.leftBound + this.radius;
          this.speedX = 0;
        }
        if (this.x + this.radius > this.rightBound) {
          this.x = this.rightBound - this.radius;
          this.speedX = 0;
        }

        this.dy += gravity;
        this.y += this.dy;

        if (this.y > floorY - this.radius) {
          this.y = floorY - this.radius;
          this.dy = 0;
          this.jumping = false;
        }

        // Bounce decay
        this.headBounce *= 0.8;
        if (this.headBounce < 0.01) this.headBounce = 0;
      }

      draw() {
        const bounceY = this.y - this.headBounce;

        // Draw shadow
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.4)";
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 8;

        // Draw head image centered at x, bounceY
        ctx.drawImage(this.img, this.x - this.radius, bounceY - this.radius, this.radius*2, this.radius*2);

        ctx.restore();

        // Simple mouth bounce overlay (optional)
        // You can add more facial animation if you want here
      }

      hit() {
        this.headBounce = 15;
      }
    }

    class Ball {
      constructor() {
        this.radius = 22;
        this.reset();
        this.spin = 0;
      }

      reset() {
        this.x = canvas.width / 2;
        this.y = 150;
        this.dx = 0; // start stationary during countdown
        this.dy = 0;
        this.spin = 0;
      }

      launch() {
        // Random launch direction
        this.dx = 6 * (Math.random() > 0.5 ? 1 : -1);
        this.dy = -10;
      }

      update() {
        this.x += this.dx;
        this.y += this.dy;
        this.dy += gravity;

        this.spin *= 0.9;

        // Floor collision
        if (this.y + this.radius > floorY) {
          this.y = floorY - this.radius;
          this.dy = -this.dy * 0.7;
          this.spin *= 0.6;
          if (Math.abs(this.dy) < 2) this.dy = 0;
        }

        // Walls bounce with spin effect
        if (this.x - this.radius < 0) {
          this.x = this.radius;
          this.dx = -this.dx;
          this.spin = -this.spin;
        }
        if (this.x + this.radius > canvas.width) {
          this.x = canvas.width - this.radius;
          this.dx = -this.dx;
          this.spin = -this.spin;
        }

        // Net collision
        if (
          this.x + this.radius > netX &&
          this.x - this.radius < netX + netWidth &&
          this.y + this.radius > floorY - netHeight
        ) {
          if (this.x < netX + netWidth / 2) this.x = netX - this.radius;
          else this.x = netX + netWidth + this.radius;
          this.dx = -this.dx;
          this.spin = -this.spin;
        }
      }

      draw() {
        // Draw volleyball image with shadow & spin rotation
        ctx.save();

        ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
        ctx.shadowBlur = 18;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.spin + performance.now() / 400);
        ctx.drawImage(ballImg, -this.radius, -this.radius, this.radius*2, this.radius*2);

        ctx.restore();
      }
    }

    // DRAW NET with sway effect
    function drawNet(frame) {
      const sway = Math.sin(frame / 20) * 2;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.75)';
      ctx.fillRect(netX + sway, floorY - netHeight, netWidth, netHeight);

      // Net stripes
      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.lineWidth = 1;
      for (let y = floorY - netHeight; y <= floorY; y += 15) {
        ctx.beginPath();
        ctx.moveTo(netX + sway, y);
        ctx.lineTo(netX + netWidth + sway, y);
        ctx.stroke();
      }
    }

    // Draw simple grass ground with waving blades
    function drawGround() {
      const grassHeight = 20;
      ctx.fillStyle = '#3A5D32';
      ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);

      ctx.strokeStyle = '#4A7A3D';
      ctx.lineWidth = 2;
      for (let x = 0; x < canvas.width; x += 12) {
        ctx.beginPath();
        const bladeHeight = 15 + Math.sin(x / 7 + performance.now() / 300) * 5;
        ctx.moveTo(x, floorY + grassHeight);
        ctx.lineTo(x, floorY + grassHeight - bladeHeight);
        ctx.stroke();
      }
    }

    // Collision check (circle to circle approx)
    function checkCollision(player, ball) {
      const dx = ball.x - player.x;
      const dy = ball.y - player.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist < ball.radius + player.radius * 0.95) {
        const dir = dx < 0 ? -1 : 1;
        ball.dx = dir * 7 + player.speedX * 0.3;
        ball.dy = -12;
        ball.spin = dir * 0.3;
        player.hit();
      }
    }

    // INIT players and ball
    const player = new Player(150, playerHeadImg, 0, netX - 5);
    const ai = new Player(canvas.width - 150, aiHeadImg, netX + netWidth + 5, canvas.width);
    const ball = new Ball();

    let playerScore = 0;
    let aiScore = 0;

    // Input handling
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.code] = true;
      if(e.code === 'ArrowUp') e.preventDefault();
    });
    window.addEventListener('keyup', e => {
      keys[e.code] = false;
    });

    function updateScore() {
      const scoreboard = document.getElementById('scoreboard');
      scoreboard.textContent = `Player: ${playerScore} | AI: ${aiScore}`;
      scoreboard.style.animation = 'pulse 0.8s ease forwards';
      setTimeout(() => {
        scoreboard.style.animation = '';
      }, 800);
    }

    // AI Logic: smooth tracking & jump
    function aiLogic() {
      if(ball.x > ai.x) ai.moveRight();
      else ai.moveLeft();

      const distToBall = Math.abs(ai.x - ball.x);
      if(distToBall < 120 && !ai.jumping && ball.dy > 0 && ball.y > ai.y - 60){
        ai.jump();
      }
    }

    // COUNTDOWN logic
    let countdownNumber = 3;
    let countdownActive = true;
    countdownOverlay.textContent = countdownNumber;

    function countdown() {
      if(countdownNumber > 1){
        countdownNumber--;
        countdownOverlay.textContent = countdownNumber;
        setTimeout(countdown, 1000);
      } else {
        countdownOverlay.textContent = 'Go!';
        setTimeout(() => {
          countdownOverlay.style.display = 'none';
          countdownActive = false;
          ball.launch(); // launch ball after countdown
        }, 1000);
      }
    }
    countdown();

    // GAME LOOP
    function gameLoop(time=0) {
      if(!countdownActive) {
        if(keys['ArrowLeft']) player.moveLeft();
        if(keys['ArrowRight']) player.moveRight();
        if(keys['ArrowUp']) player.jump();

        player.update();
        aiLogic();
        ai.update();
        ball.update();

        checkCollision(player, ball);
        checkCollision(ai, ball);

        if(ball.x - ball.radius <= 0){
          aiScore++;
          updateScore();
          ball.reset();
          countdownActive = true;
          countdownNumber = 3;
          countdownOverlay.style.display = 'flex';
          countdownOverlay.textContent = countdownNumber;
          countdown();
        } else if(ball.x + ball.radius >= canvas.width){
          playerScore++;
          updateScore();
          ball.reset();
          countdownActive = true;
          countdownNumber = 3;
          countdownOverlay.style.display = 'flex';
          countdownOverlay.textContent = countdownNumber;
          countdown();
        }
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawGround();
      drawNet(time);

      player.draw();
      ai.draw();
      ball.draw();

      requestAnimationFrame(gameLoop);
    }

    // Score animation keyframes
    const styleSheet = document.createElement('style');
    styleSheet.type = 'text/css';
    styleSheet.innerText = `
    @keyframes pulse {
      0%, 100% { text-shadow: 0 0 10px #00FFB3; }
      50% { text-shadow: 0 0 25px #00FFD6; }
    }`;
    document.head.appendChild(styleSheet);

    // Wait for images to load before starting game loop
    let loadedImages = 0;
    [playerHeadImg, aiHeadImg, ballImg].forEach(img => {
      img.onload = () => {
        loadedImages++;
        if(loadedImages === 3) {
          updateScore();
          requestAnimationFrame(gameLoop);
        }
      }
    });
  </script>
</body>
</html>
